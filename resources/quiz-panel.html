<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Multiple Question Quiz</title>
    <style>
      @font-face {
          font-family: 'Outfit';
          src: url('https://fonts.googleapis.com/css2?family=Outfit:wght@100..900&display=swap');
      }

      body { font-family: 'Outfit', sans-serif; background-color: #000000; color: aliceblue; margin: 0; box-sizing: border-box; height: 100vh; display: flex; justify-content: center; text-align: center; }
      .quiz-container { box-sizing: border-box; width: calc(100% - 50px); max-width: 600px; padding: 2em; border-radius: 20px; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); height: calc(100% - 50px); display: flex; flex-direction: column; justify-content: center; align-items: center; }
      h1 { margin-top: 15px; margin-bottom: 10px; }
      p { margin-top: 10px; margin-bottom: 10px;   text-align:center; font-size: clamp(18px, 3cqw, 28px); line-height: 1.15; text-wrap: balance; overflow-wrap: anywhere; hyphens: auto; }
      .choices { display: flex; flex-direction: column; padding: 10px; }
      .choice { font-family: 'Outfit', sans-serif; font-weight: 300; font-size: 1em; margin: 5px 0; padding: .5em .75em; background-color: #393939; color: white; border: none; border-radius: 5px; cursor: pointer; width: 100%; max-width: 550px; height: 50px; box-sizing: border-box; transition: background-color 0.2s ease; }
      .choice:hover { background-color: #4a5056; }
      .choice.disable-hover:hover { background-color: #393939; }
      .correct-answer { background-color: rgba(15, 162, 15, 0.694); }
      .incorrect-answer { background-color: rgba(210, 47, 47, 0.567); }
      .feedback-container { position: relative; width: 400px; height: 20px; margin-top: 1px; background-color: rgba(255, 255, 255, 0); } 
      .feedback-background { position: absolute; top: 0; left: 0; width: 400px; height: 20px; background-color: rgba(255, 255, 255, 0); }
      .feedback-content { position: relative; z-index: 1; margin: 0; line-height: 20px; width: 100%; }
      .quiz-title { text-align: center; }
      .timer-bar-container { position: relative; height: 5px; width: 100%; margin-bottom: 20px; margin-top: 25px; }
      .timer-bar-background { position: absolute; top: 0; left: 0; height: 5px; width: 100%; background-color: rgba(255, 255, 255, 0.10); opacity: 100; border-radius: 2px; }
      .timer-bar { position: absolute; top: 0; left: 0; height: 5px; background-color: rgb(170, 170, 170); width: 0%; border-radius: 2px; transition: width linear; } 
</style>
</head>
<body>
  <div class="quiz-container">
    <div class="timer-bar-container" id="timer-bar-container" style="display: none;">
      <div class="timer-bar-background"></div>
      <div class="timer-bar" id="timer-bar"></div>
    </div>
    <h1 id="quiz-title"></h1>
    <div class="question">
      <p id="question-text"></p>
      <div class="choices" id="choices-container">
        <!-- Choice buttons will be dynamically created here -->
      </div>
      <div class="feedback-container">
        <div class="feedback-background"></div>
        <p id="feedback" class="feedback-content"></p>
      </div>
    </div>
  </div>

  <script>
    // --- Existing globals (kept to preserve behavior) ---
    let analyticsKey = 'null';
    let actionID = 'null';
    let timerOn = false;
    let timerDuration = 10;
    let endMessageWin = 'Congratulations! You answered all questions correctly!';
    let endMessageLose = 'Keep practicing to improve your score.';
    let limitResponse = 'None';
    let popupID = 'null';

    // Multi-question state
    let currentQuestion = 0;
    let correctAnswers = 0;
    let questions = [];
    let timerInterval;
    let gotData = false; // NEW: track whether we received data

    // --- Utilities (match single-question panel) ---
    const coalesce = (v, fallback) => (v !== undefined ? v : fallback);

    function parseIncomingQuestions(payload) {
      // Accept several shapes:
      // - payload.content = [ {question, choices, correct}, ... ]
      // - payload.content = { questions: [...] }
      // - payload.questions = [...]
      // - payload = [ ... ] (edge cases)
      const c = payload?.content;
      if (Array.isArray(c)) return c;
      if (c && Array.isArray(c.questions)) return c.questions;
      if (Array.isArray(payload?.questions)) return payload.questions;
      if (Array.isArray(payload)) return payload;
      return [];
    }

    // --- Timer hygiene (stop before start; clear when hidden) ---
    function startTimer() {
      const timerBar = document.getElementById("timer-bar");
      if (!timerBar) return;

      stopTimer(); // clear any previous timeout/transition first

      timerBar.style.transition = 'none';
      timerBar.style.width = '0%';
      // Force reflow so reset takes effect
      void timerBar.offsetWidth;

      timerBar.style.transition = `width ${Number(timerDuration)}s linear`;
      timerBar.style.width = '100%';

      timerInterval = setTimeout(() => {
        moveToNextQuestion();
      }, Math.max(0, Number(timerDuration)) * 1000);
    }

    function stopTimer() {
      clearTimeout(timerInterval);
      const timerBar = document.getElementById("timer-bar");
      if (!timerBar) return;
      const computedStyle = getComputedStyle(timerBar);
      const width = computedStyle.width; // keep your existing px freeze
      timerBar.style.transition = 'none';
      timerBar.style.width = width;
    }

    // --- Rendering & flow ---
    function showQuestion() {
      if (questions.length > 0 && currentQuestion < questions.length) {
        const questionText = document.getElementById("question-text");
        questionText.textContent = questions[currentQuestion].question;

        const choicesContainer = document.getElementById("choices-container");
        choicesContainer.innerHTML = ''; // Clear existing choices

        questions[currentQuestion].choices.forEach((choice, index) => {
          const button = document.createElement('button');
          button.className = 'choice';
          button.textContent = choice;
          button.onclick = () => checkAnswer(index);
          choicesContainer.appendChild(button);
        });

        const feedback = document.getElementById("feedback");
        feedback.textContent = "";

        const tbc = document.getElementById("timer-bar-container");
        if (timerOn) {
          tbc.style.display = "block";
          stopTimer();     // ensure clean start
          startTimer();
        } else {
          tbc.style.display = "none";
          stopTimer();     // clear if hidden
        }
      } else {
        const questionText = document.getElementById("question-text");
        questionText.textContent = "No questions available. Please reload the quiz...";
      }
    }

    function moveToNextQuestion() {
      currentQuestion++;
      if (currentQuestion < questions.length) {
        showQuestion();
      } else {
        const quizContainer = document.querySelector(".quiz-container");
        const allCorrect = correctAnswers === questions.length;
        const resultMessage = `You got ${correctAnswers} out of ${questions.length} questions correct.`;
        const additionalMessage = allCorrect ? endMessageWin : endMessageLose;

        quizContainer.innerHTML = `<p>${resultMessage}</p><p>${additionalMessage}</p>`;
        console.log('Quiz Finished: ', correctAnswers);
        sendAnalytics();
      }
    }

    function checkAnswer(selected) {
      stopTimer(); // Stop the timer when an answer is checked

      const choices = document.querySelectorAll(".choice");

      // Disable hover effect on all choices by removing the hover style
      choices.forEach(choice => choice.style.pointerEvents = 'none');

      // Highlight the correct answer immediately
      choices[questions[currentQuestion].correct].classList.add('correct-answer');

      // Highlight the chosen incorrect answer, if incorrect
      if (selected !== questions[currentQuestion].correct) {
        choices[selected].classList.add('incorrect-answer');
      }

      // Add feedback after highlighting
      const feedback = document.getElementById("feedback");
      if (selected === questions[currentQuestion].correct) {
        feedback.textContent = "Correct!";
        correctAnswers++;
      } else {
        feedback.textContent = "Incorrect!";
      }

      setTimeout(() => {
        // Remove the highlight and re-enable the hover effect after 1.5s and move to the next question
        choices.forEach(choice => {
          choice.classList.remove('correct-answer');
          choice.classList.remove('incorrect-answer');
          choice.style.pointerEvents = '';
        });
        moveToNextQuestion();
      }, 1500);
    }

    // --- Analytics (unchanged payload shape) ---
    function sendAnalytics() {
      const allCorrect = correctAnswers === questions.length; // Calculate allCorrect
      parent.postMessage({ 
        action: 'send-results',
        popupID: popupID,
        result: correctAnswers,
        analytics: analyticsKey,
        allCorrect: allCorrect,
        limitResponse: limitResponse,
        actionID: actionID
      }, '*');
    }

    // --- Unified updater (matches single-question panelâ€™s coalescing) ---
    function applyUpdate(data) {
      // Title
      const quizTitleElement = document.getElementById('quiz-title');
      if (quizTitleElement) {
        quizTitleElement.textContent = data.quizTitle || 'Multiple Choice Quiz';
      }

      // Respect false/0 and keep prior values if undefined
      analyticsKey   = (data.analytics      ?? analyticsKey);
      popupID        = (data.popupID        ?? popupID);
      limitResponse  = (data.limitResponse  ?? limitResponse);
      actionID       = (data.actionID       ?? actionID);
      timerOn        = (data.timerOn !== undefined) ? Boolean(data.timerOn) : timerOn;
      timerDuration  = (data.timerDuration !== undefined) ? Number(data.timerDuration) : timerDuration;
      endMessageWin  = (data.endMessageWin  ?? endMessageWin);
      endMessageLose = (data.endMessageLose ?? endMessageLose);

      // Questions: robust to multiple shapes
      const incoming = parseIncomingQuestions(data);
      if (incoming.length) {
        questions = incoming;
        // reset progress if new set arrives
        currentQuestion = 0;
        correctAnswers = 0;
      }

      gotData = true;
      showQuestion();
      console.log('[MULTI QUIZ] Updated:', { timerOn, timerDuration, questions: questions.length });
    }

    // --- Messaging (same action name as single-question) ---
    window.addEventListener('message', (event) => {
      const data = event?.data || {};
      if (data.action !== 'update-quiz') return;
      applyUpdate(data);
    });

    // --- Handshake & one retry (matches single-question flow) ---
    window.addEventListener('DOMContentLoaded', () => {
      // Immediately ask the parent for data
      parent.postMessage({ action: 'request-quiz', popupID }, '*');

      // Retry once shortly if nothing has arrived yet
      setTimeout(() => {
        if (!gotData) {
          parent.postMessage({ action: 'request-quiz', popupID }, '*');
        }
      }, 2500);

      // Optional: initial placeholders (kept from your original)
      document.getElementById('quiz-title').textContent = ' ';
      document.getElementById("question-text").textContent = "  ";
    });
  </script>
</body>
</html>
