<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
      @font-face {
          font-family: 'Outfit';
          src: url('https://fonts.googleapis.com/css2?family=Outfit:wght@100..900&display=swap');
      }

      body { font-family: 'Outfit', sans-serif; background-color: #000000; color: aliceblue; margin: 0; box-sizing: border-box; height: 100vh; display: flex; justify-content: center; text-align: center; }
      .quiz-container { box-sizing: border-box; width: calc(100% - 50px); max-width: 600px; padding: 2em; border-radius: 20px; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); height: calc(100% - 50px); display: flex; flex-direction: column; justify-content: center; align-items: center; }
      h1 { margin-top: 15px; margin-bottom: 10px; }
      p { margin-top: 10px; margin-bottom: 10px;   text-align:center; font-size: clamp(18px, 3cqw, 28px); line-height: 1.15; text-wrap: balance; overflow-wrap: anywhere; hyphens: auto; }
      .choices { display: flex; flex-direction: column; padding: 10px; }
      .choice { font-family: 'Outfit', sans-serif; font-weight: 300; font-size: 1em; margin: 5px 0; padding: .5em .75em; background-color: #393939; color: white; border: none; border-radius: 5px; cursor: pointer; width: 100%; max-width: 550px; height: 60px; box-sizing: border-box; transition: background-color 0.2s ease; }
      .choice:hover { background-color: #4a5056; }
      .choice.disable-hover:hover { background-color: #393939; }
      .correct-answer { background-color: rgba(15, 162, 15, 0.694); }
      .incorrect-answer { background-color: rgba(210, 47, 47, 0.567); }
      .feedback-container { position: relative; width: 400px; height: 20px; margin-top: 1px; background-color: rgba(255, 255, 255, 0); } 
      .feedback-background { position: absolute; top: 0; left: 0; width: 400px; height: 20px; background-color: rgba(255, 255, 255, 0); }
      .feedback-content { position: relative; z-index: 1; margin: 0; line-height: 20px; width: 100%; }
      .quiz-title { text-align: center; }
      .timer-bar-container { position: relative; height: 5px; width: 100%; margin-bottom: 20px; }
      .timer-bar-background { position: absolute; top: 0; left: 0; height: 5px; width: 100%; background-color: rgba(255, 255, 255, 0.10); opacity: 100; border-radius: 2px; }
      .timer-bar { position: absolute; top: 0; left: 0; height: 5px; background-color: rgb(170, 170, 170); width: 0%; border-radius: 2px; transition: width linear; } 
</style>
  
</head>
<body>
  <div class="quiz-container">
    <div class="timer-bar-container" id="timer-bar-container" style="display: none;">
      <div class="timer-bar-background"></div>
      <div class="timer-bar" id="timer-bar"></div>
    </div>
    <div class="question">
      <p id="question-text"></p>
      <div class="choices" id="choices-container">
        <!-- Choice buttons will be dynamically created here -->
      </div>
      <div class="feedback-container">
        <div class="feedback-background"></div>
        <p id="feedback" class="feedback-content"></p>
      </div>
    </div>
  </div>
  <script>
  // --- State ---
  let state = {
    analyticsKey: null,
    popupID: null,
    timerOn: false,
    timerDuration: 10,
    endMessageWin: 'Congratulations! You answered correctly!',
    endMessageLose: 'Try again next time.',
    randomQuestion: false,
    questions: [],
    selectedQuestion: null,
    limitResponse: undefined,
    actionID: 'none',
    activityID: 'none',
    adminUser: 'none',
    zoneId: null,
    isActivity: false,
    options: {},
    timerHandle: null,
    gotData: false
  };

  // --- Utilities ---
  const coalesce = (v, fallback) => (v !== undefined ? v : fallback);

  function parseIncomingQuestions(payload) {
    // Accept several shapes:
    // - payload.content = [ {question, choices, correct}, ... ]
    // - payload.content = { questions: [...] }
    // - payload.questions = [...]
    // - payload = [ ... ] (edge cases)
    const c = payload?.content;
    if (Array.isArray(c)) return c;
    if (c && Array.isArray(c.questions)) return c.questions;
    if (Array.isArray(payload?.questions)) return payload.questions;
    if (Array.isArray(payload)) return payload;
    return [];
  }

  function getChoiceText(choice) {
    if (choice == null) return null;
    if (typeof choice === 'string') return choice;
    if (typeof choice === 'object') {
      // common object shapes: {label}, {text}, {value}
      return choice.label ?? choice.text ?? (choice.value != null ? String(choice.value) : null);
    }
    return String(choice);
  }

  function stopTimer() {
    if (state.timerHandle) {
      clearTimeout(state.timerHandle);
      state.timerHandle = null;
    }
    const timerBar = document.getElementById("timer-bar");
    if (timerBar) {
      // Freeze where it currently is
      const width = getComputedStyle(timerBar).width;
      timerBar.style.transition = 'none';
      timerBar.style.width = width;
    }
  }

  function startTimer() {
    const timerBar = document.getElementById("timer-bar");
    if (!timerBar) return;

    // 1) Clear any prior timeout & freeze state BEFORE starting a new run
    stopTimer();

    // 2) Reset the bar to 0% with no transition
    timerBar.style.transition = 'none';
    timerBar.style.width = '0%';

    // 3) Force reflow so the browser commits the reset
    void timerBar.offsetWidth;

    // 4) Start the animation
    timerBar.style.transition = `width ${state.timerDuration}s linear`;
    timerBar.style.width = '100%';

    // 5) Set up the logical timeout to end the quiz
    state.timerHandle = setTimeout(() => checkAnswer(), state.timerDuration * 1000);
  }


  function clearChoices() {
    const choicesContainer = document.getElementById("choices-container");
    if (choicesContainer) choicesContainer.innerHTML = '';
    const feedback = document.getElementById("feedback");
    if (feedback) feedback.textContent = '';
    // Reset timer bar visibility
    const tbc = document.getElementById("timer-bar-container");
    if (tbc) tbc.style.display = state.timerOn ? 'block' : 'none';
  }

  function selectQuestion() {
    if (!state.questions || state.questions.length === 0) {
      state.selectedQuestion = null;
      return;
    }
    state.selectedQuestion = state.randomQuestion
      ? state.questions[Math.floor(Math.random() * state.questions.length)]
      : state.questions[0];
  }

  function render() {

    const questionText = document.getElementById("question-text");
    const tbc = document.getElementById("timer-bar-container");

    if (!state.selectedQuestion) {
      if (questionText) questionText.textContent = "No questions available. Please wait…";
      clearChoices();
      if (tbc) tbc.style.display = 'none';
      return;
    }

    // Question text
    if (questionText) questionText.textContent = state.selectedQuestion.question || '';

    // Choices
    clearChoices();
    const choicesContainer = document.getElementById("choices-container");
    if (choicesContainer && Array.isArray(state.selectedQuestion.choices)) {
      state.selectedQuestion.choices.forEach((choice, index) => {
        const button = document.createElement('button');
        button.className = 'choice';
        button.textContent = choice;
        button.onclick = () => checkAnswer(index);
        choicesContainer.appendChild(button);
      });
    }

    // Timer
    if (state.timerOn && tbc) {
      tbc.style.display = 'block';
      stopTimer();       // make sure no stale timeout/transition survives
      startTimer();      // now begin a fresh run
    } else if (tbc) {
      tbc.style.display = 'none';
      stopTimer();       // optional: also clear if we’re hiding the timer
    }
  }

  function applyUpdate(payload) {
    // Merge & normalize
    state.analyticsKey    = coalesce(payload.analytics, state.analyticsKey);
    state.popupID         = coalesce(payload.popupID, state.popupID);
    state.timerOn         = coalesce(payload.timerOn, state.timerOn);
    state.timerDuration   = coalesce(payload.timerDuration, state.timerDuration);
    state.endMessageWin   = coalesce(payload.endMessageWin, state.endMessageWin);
    state.endMessageLose  = coalesce(payload.endMessageLose, state.endMessageLose);
    state.randomQuestion  = coalesce(payload.randomQuestion, state.randomQuestion);
    state.limitResponse   = coalesce(payload.limitResponse, state.limitResponse);
    state.actionID        = coalesce(payload.actionID, state.actionID);
    state.activityID      = coalesce(payload.activityID, state.activityID);
    state.adminUser       = coalesce(payload.adminUser, state.adminUser);
    state.zoneId          = coalesce(payload.zoneId, state.zoneId);
    state.isActivity      = !!payload.isActivityComponent;
    state.options         = coalesce(payload.options, state.options);
    state.quizTitle       = coalesce(payload.quizTitle, state.quizTitle);

    // Questions last (depends on shape)
    const incoming = parseIncomingQuestions(payload);
    if (incoming.length) state.questions = incoming;

    selectQuestion();
    stopTimer();
    render();

    state.gotData = true;
  }

  function showFeedback(isCorrect) {
    const feedback = document.getElementById("feedback");
    if (feedback) feedback.textContent = isCorrect ? state.endMessageWin : state.endMessageLose;
  }

  function sendAnalytics( quizResult, responseText, correctAnswerText ) {
    const allCorrect = quizResult === 1;

    parent.postMessage({
      action: 'send-results',
      result: quizResult,
      response: responseText,
      correctAnswer: correctAnswerText,
      // --- existing metadata ---
      analytics: state.analyticsKey,
      allCorrect,
      limitResponse: state.limitResponse,
      actionID: state.actionID,
      popupID: state.popupID,
      isActivityComponent: state.isActivity,
      adminUser: state.adminUser,
      zoneId: state.zoneId,
      options: state.options
    }, '*');
  }


  function checkAnswer(selected) {
    stopTimer();
    const choices = document.querySelectorAll(".choice");
    choices.forEach(choice => (choice.style.pointerEvents = 'none'));
    if (!state.selectedQuestion) return;

    // highlight correct
    if (choices[state.selectedQuestion.correct]) {
      choices[state.selectedQuestion.correct].classList.add('correct-answer');
    }

    let quizResult, allCorrect;
    if (selected === state.selectedQuestion.correct) {
      quizResult = 1; allCorrect = true;
    } else {
      if (selected !== undefined && choices[selected]) {
        choices[selected].classList.add('incorrect-answer');
      }
      quizResult = 0; allCorrect = false;
    }

    // --- NEW: derive human-readable strings for analytics ---
    const choiceList = Array.isArray(state.selectedQuestion?.choices) ? state.selectedQuestion.choices : [];
    const correctIdx  = (state.selectedQuestion?.correct ?? -1);
    const selectedIdx = (selected ?? null);

    const responseText      = (selectedIdx != null && choiceList[selectedIdx] !== undefined)
      ? getChoiceText(choiceList[selectedIdx])
      : null;

    const correctAnswerText = (correctIdx >= 0 && choiceList[correctIdx] !== undefined)
      ? getChoiceText(choiceList[correctIdx])
      : null;

    const questionText = state.selectedQuestion?.question ?? null;

    // Send both numeric indices and text versions
    sendAnalytics(
      quizResult,
      responseText,
      correctAnswerText
    );

    console.log('[QUIZ PANEL] Send Analytics: ', { quizResult, responseText, correctAnswerText });
    showFeedback(allCorrect);
  }

  // --- Messaging ---
  function handleMessage(event) {
    console.log('[QUIZ PANEL] Message Recieved: ', event);
    const data = event?.data || {};
    if (data.action !== 'update-quiz') return;
    applyUpdate(data);
  }
  window.addEventListener('message', handleMessage);

  // --- Handshake & fallback fetch ---
  window.addEventListener('DOMContentLoaded', () => {
    // Tell parent we're ready, and immediately request data.
    parent.postMessage({ action: 'request-quiz', popupID: state.popupID }, '*');

    // Small retry if nothing arrives very quickly (handles early-missed postMessage)
    setTimeout(() => {
      if (!state.gotData) {
        parent.postMessage({ action: 'request-quiz', popupID: state.popupID }, '*');
      }
    }, 1000);
  });
</script>

</body>


</html>
